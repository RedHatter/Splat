{
    "fileTypes": [
        "hs"
    ], 
    "keyEquivalent": "^~H", 
    "name": "Haskell", 
    "patterns": [
        {
            "captures": {
                "1": {
                    "name": "punctuation.definition.entity.haskell"
                }, 
                "2": {
                    "name": "punctuation.definition.entity.haskell"
                }
            }, 
            "comment": "In case this regex seems unusual for an infix operator, note that Haskell allows any ordinary function application (elem 4 [1..10]) to be rewritten as an infix expression (4 `elem` [1..10]).", 
            "match": "(`)[a-zA-Z_']*?(`)", 
            "name": "keyword.operator.function.infix.haskell"
        }, 
        {
            "match": "\\(\\)", 
            "name": "constant.language.unit.haskell"
        }, 
        {
            "match": "\\[\\]", 
            "name": "constant.language.empty-list.haskell"
        }, 
        {
            "begin": "\\b(module)\\b", 
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "end": "(where)", 
            "endCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "name": "meta.declaration.module.haskell", 
            "patterns": [
                {
                    "include": "#module_name"
                }, 
                {
                    "include": "#module_exports"
                }, 
                {
                    "match": "[a-z]+", 
                    "name": "invalid"
                }
            ]
        }, 
        {
            "begin": "\\b(class)\\b", 
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "end": "\\b(where)\\b", 
            "endCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "name": "meta.declaration.class.haskell", 
            "patterns": [
                {
                    "match": "\\b(Monad|Functor|Eq|Ord|Read|Show|Num|(Frac|Ra)tional|Enum|Bounded|Real(Frac|Float)?|Integral|Floating)\\b", 
                    "name": "support.class.prelude.haskell"
                }, 
                {
                    "match": "[A-Z][A-Za-z_']*", 
                    "name": "entity.other.inherited-class.haskell"
                }, 
                {
                    "match": "\\b[a-z][a-zA-Z0-9_']*\\b", 
                    "name": "variable.other.generic-type.haskell"
                }
            ]
        }, 
        {
            "begin": "\\b(instance)\\b", 
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "end": "\\b(where)\\b|$", 
            "endCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "name": "meta.declaration.instance.haskell", 
            "patterns": [
                {
                    "include": "#type_signature"
                }
            ]
        }, 
        {
            "begin": "\\b(import)\\b", 
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "end": "($|;)", 
            "name": "meta.import.haskell", 
            "patterns": [
                {
                    "match": "(qualified|as|hiding)", 
                    "name": "keyword.other.haskell"
                }, 
                {
                    "include": "#module_name"
                }, 
                {
                    "include": "#module_exports"
                }, 
                {
                    "include": "#comments"
                }
            ]
        }, 
        {
            "begin": "(deriving)\\s*\\(", 
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }
            }, 
            "end": "\\)", 
            "name": "meta.deriving.haskell", 
            "patterns": [
                {
                    "match": "\\b[A-Z][a-zA-Z_']*", 
                    "name": "entity.other.inherited-class.haskell"
                }
            ]
        }, 
        {
            "match": "\\b(deriving|where|data|type|case|of|let|in|newtype|default)\\b", 
            "name": "keyword.other.haskell"
        }, 
        {
            "match": "\\binfix[lr]?\\b", 
            "name": "keyword.operator.haskell"
        }, 
        {
            "match": "\\b(do|if|then|else)\\b", 
            "name": "keyword.control.haskell"
        }, 
        {
            "comment": "Floats are always decimal", 
            "match": "\\b([0-9]+\\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+)\\b", 
            "name": "constant.numeric.float.haskell"
        }, 
        {
            "match": "\\b([0-9]+|0([xX][0-9a-fA-F]+|[oO][0-7]+))\\b", 
            "name": "constant.numeric.haskell"
        }, 
        {
            "captures": {
                "1": {
                    "name": "punctuation.definition.preprocessor.c"
                }
            }, 
            "comment": "In addition to Haskell's \"native\" syntax, GHC permits the C preprocessor to be run on a source file.", 
            "match": "^\\s*(#)\\s*\\w+", 
            "name": "meta.preprocessor.c"
        }, 
        {
            "include": "#pragma"
        }, 
        {
            "begin": "\"", 
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.haskell"
                }
            }, 
            "end": "$|\"", 
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.haskell"
                }
            }, 
            "name": "string.quoted.double.haskell", 
            "patterns": [
                {
                    "match": "\\\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\&])", 
                    "name": "constant.character.escape.haskell"
                }, 
                {
                    "match": "\\\\o[0-7]+|\\\\x[0-9A-Fa-f]+|\\\\[0-9]+", 
                    "name": "constant.character.escape.octal.haskell"
                }, 
                {
                    "match": "\\^[A-Z@\\[\\]\\\\\\^_]", 
                    "name": "constant.character.escape.control.haskell"
                }
            ]
        }, 
        {
            "begin": "\\[(?:|e|d|t|p)\\|", 
            "beginCaptures": {
                "0": {
                    "name": "keyword.other.quasibracket.haskell"
                }
            }, 
            "comment": "Points out splices in ast quotes", 
            "end": "(.*)(\\|\\])", 
            "endCaptures": {
                "1": {
                    "name": "string.quasiquoted.haskell"
                }, 
                "2": {
                    "name": "keyword.other.quasibracket.haskell"
                }
            }, 
            "name": "meta.other.quasiquote.haskell", 
            "patterns": [
                {
                    "match": "\\$\\(", 
                    "name": "keyword.other.splice.haskell"
                }, 
                {
                    "match": "\\$", 
                    "name": "string.quasiquoted.haskell"
                }, 
                {
                    "match": "[^$]*", 
                    "name": "string.quasiquoted.haskell"
                }
            ]
        }, 
        {
            "comment": "Highlight the beginning of a splice.", 
            "match": "\\$\\(", 
            "name": "keyword.other.splice.haskell"
        }, 
        {
            "begin": "\\[[a-zA-Z0-9_']*\\|", 
            "beginCaptures": {
                "0": {
                    "name": "keyword.other.quasibracket.haskell"
                }
            }, 
            "end": "(.*)(\\|\\])", 
            "endCaptures": {
                "1": {
                    "name": "string.quasiquoted.haskell"
                }, 
                "2": {
                    "name": "keyword.other.quasibracket.haskell"
                }
            }, 
            "name": "meta.other.quasiquote.haskell", 
            "patterns": [
                {
                    "match": ".*", 
                    "name": "string.quasiquoted.haskell"
                }
            ]
        }, 
        {
            "captures": {
                "1": {
                    "name": "punctuation.definition.string.begin.haskell"
                }, 
                "2": {
                    "name": "constant.character.escape.haskell"
                }, 
                "3": {
                    "name": "constant.character.escape.octal.haskell"
                }, 
                "4": {
                    "name": "constant.character.escape.hexadecimal.haskell"
                }, 
                "5": {
                    "name": "constant.character.escape.control.haskell"
                }, 
                "6": {
                    "name": "punctuation.definition.string.end.haskell"
                }
            }, 
            "match": "(?x)\n\t\t\t(')\n\t\t\t(?:\n\t\t\t\t[\\ -\\[\\]-~]                             # Basic Char\n\t\t\t  | (\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE\n\t\t\t\t\t|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS\n\t\t\t\t\t|US|SP|DEL|[abfnrtv\\\\\\\"'\\&]))       # Escapes\n\t\t\t  | (\\\\o[0-7]+)                             # Octal Escapes\n\t\t\t  | (\\\\x[0-9A-Fa-f]+)                       # Hexadecimal Escapes\n\t\t\t  | (\\^[A-Z@\\[\\]\\\\\\^_])                     # Control Chars\n\t\t\t)\n\t\t\t(')\n\t\t\t", 
            "name": "string.quoted.single.haskell"
        }, 
        {
            "begin": "^\\s*([a-z_][a-zA-Z0-9_']*|\\([|!%$+\\-.,=</>]+\\))\\s*(::)", 
            "beginCaptures": {
                "1": {
                    "name": "entity.name.function.haskell"
                }, 
                "2": {
                    "name": "keyword.other.double-colon.haskell"
                }
            }, 
            "end": "(?x)\n\t\t\t\t  ^(data|newtype|type|class|deriving)\\s  # When a top level declaration starts\n\t\t\t\t| ^[^=]*(=)[\\sa-zA-Z0-9_\\(]                # A function declaration\n\t\t\t", 
            "endCaptures": {
                "1": {
                    "name": "keyword.other.haskell"
                }, 
                "2": {
                    "name": "keyword.operator.haskell"
                }
            }, 
            "name": "meta.function.type-declaration.haskell", 
            "patterns": [
                {
                    "include": "#type_signature"
                }
            ]
        }, 
        {
            "match": "\\b[A-Z]\\w*\\b", 
            "name": "constant.other.haskell"
        }, 
        {
            "include": "#comments"
        }, 
        {
            "include": "#infix_op"
        }, 
        {
            "comment": "In case this regex seems overly general, note that Haskell permits the definition of new operators which can be nearly any string of punctuation characters, such as $%^&*.", 
            "match": "[|!%$?~+:\\-.=</>\\\\]+", 
            "name": "keyword.operator.haskell"
        }, 
        {
            "match": ",", 
            "name": "punctuation.separator.comma.haskell"
        }
    ], 
    "repository": {
        "block_comment": {
            "applyEndPatternLast": 1, 
            "begin": "\\{-(?!#)", 
            "captures": {
                "0": {
                    "name": "punctuation.definition.comment.haskell"
                }
            }, 
            "end": "-\\}", 
            "name": "comment.block.haskell", 
            "patterns": [
                {
                    "include": "#block_comment"
                }
            ]
        }, 
        "comments": {
            "patterns": [
                {
                    "captures": {
                        "1": {
                            "name": "punctuation.definition.comment.haskell"
                        }
                    }, 
                    "match": "(--).*$\\n?", 
                    "name": "comment.line.double-dash.haskell"
                }, 
                {
                    "include": "#block_comment"
                }
            ]
        }, 
        "infix_op": {
            "match": "(\\([|!%$+:\\-.=</>]+\\)|\\(,+\\))", 
            "name": "entity.name.function.infix.haskell"
        }, 
        "module_exports": {
            "begin": "\\(", 
            "end": "\\)", 
            "name": "meta.declaration.exports.haskell", 
            "patterns": [
                {
                    "match": "\\b[a-z][a-zA-Z_'0-9]*", 
                    "name": "entity.name.function.haskell"
                }, 
                {
                    "match": "\\b[A-Z][A-Za-z_'0-9]*", 
                    "name": "storage.type.haskell"
                }, 
                {
                    "match": ",", 
                    "name": "punctuation.separator.comma.haskell"
                }, 
                {
                    "include": "#infix_op"
                }, 
                {
                    "comment": "So named because I don't know what to call this.", 
                    "match": "\\(.*?\\)", 
                    "name": "meta.other.unknown.haskell"
                }, 
                {
                    "include": "#comments"
                }
            ]
        }, 
        "module_name": {
            "match": "[A-Z][A-Za-z._']*", 
            "name": "support.other.module.haskell"
        }, 
        "pragma": {
            "begin": "\\{-#", 
            "end": "#-\\}", 
            "name": "meta.preprocessor.haskell", 
            "patterns": [
                {
                    "match": "\\b(LANGUAGE|UNPACK|INLINE)\\b", 
                    "name": "keyword.other.preprocessor.haskell"
                }
            ]
        }, 
        "type_signature": {
            "patterns": [
                {
                    "include": "#pragma"
                }, 
                {
                    "match": "->", 
                    "name": "keyword.other.arrow.haskell"
                }, 
                {
                    "match": "=>", 
                    "name": "keyword.other.big-arrow.haskell"
                }, 
                {
                    "match": "\\b[a-z][a-zA-Z0-9_']*\\b", 
                    "name": "variable.other.generic-type.haskell"
                }, 
                {
                    "match": "\\b[A-Z][a-zA-Z0-9_']*\\b", 
                    "name": "storage.type.haskell"
                }, 
                {
                    "match": "\\(\\)", 
                    "name": "support.constant.unit.haskell"
                }, 
                {
                    "include": "#comments"
                }
            ]
        }
    }, 
    "scopeName": "source.haskell", 
    "uuid": "5C034675-1F6D-497E-8073-369D37E2FD7D"
}
